use std::time::Duration;

/// Metadata generated by AI for a new session
#[derive(Debug, Clone)]
pub struct SessionMetadata {
    /// Short title (under 10 words) for display in UI
    pub title: String,

    /// Brief description (1-2 sentences) explaining the task
    pub description: String,

    /// Sanitized git branch name (kebab-case, 2-4 words)
    pub branch_name: String,
}

impl Default for SessionMetadata {
    fn default() -> Self {
        Self {
            title: "New Session".to_owned(),
            description: "AI coding session".to_owned(),
            branch_name: "session".to_owned(),
        }
    }
}

/// Generate session metadata using the Claude CLI
///
/// This function invokes the `claude` CLI tool with structured JSON output
/// to generate title, description, and branch name based on the repository path
/// and initial prompt.
///
/// Retries up to 3 times with exponential backoff (2s, 4s, 8s) on failure.
///
/// # Arguments
/// * `repo_path` - Path to the repository
/// * `initial_prompt` - The user's initial prompt/task description
///
/// # Returns
/// Returns SessionMetadata with title, description, and sanitized branch name.
/// Falls back to defaults if the CLI is not available, fails to execute, or returns invalid output.
///
/// # Example
/// ```ignore
/// let metadata = generate_session_name_ai("/home/user/my-repo", "Fix login bug").await;
/// // Returns SessionMetadata { title: "Fix login bug", description: "...", branch_name: "fix-login-bug" }
/// ```
pub async fn generate_session_name_ai(repo_path: &str, initial_prompt: &str) -> SessionMetadata {
    match generate_with_retries(repo_path, initial_prompt).await {
        Ok(metadata) => {
            tracing::info!(
                repo = %repo_path,
                title = %metadata.title,
                branch_name = %metadata.branch_name,
                "AI-generated session metadata"
            );
            metadata
        }
        Err(e) => {
            tracing::error!(
                error = %e,
                repo_path = %repo_path,
                prompt_length = initial_prompt.len(),
                "Failed to generate AI metadata after all retries, using fallback"
            );
            SessionMetadata::default()
        }
    }
}

async fn generate_with_retries(
    repo_path: &str,
    initial_prompt: &str,
) -> anyhow::Result<SessionMetadata> {
    const MAX_RETRIES: u32 = 3;
    const INITIAL_BACKOFF_SECS: u64 = 2;

    for attempt in 1..=MAX_RETRIES {
        tracing::info!(
            attempt = attempt,
            max_retries = MAX_RETRIES,
            repo_path = %repo_path,
            prompt_length = initial_prompt.len(),
            "Attempting to generate session metadata"
        );

        match generate_with_timeout(repo_path, initial_prompt).await {
            Ok(metadata) => {
                if attempt > 1 {
                    tracing::info!(
                        attempt = attempt,
                        "Successfully generated metadata after retry"
                    );
                }
                return Ok(metadata);
            }
            Err(e) if attempt < MAX_RETRIES => {
                let backoff_secs = INITIAL_BACKOFF_SECS * (1 << (attempt - 1)); // 2s, 4s, 8s
                tracing::warn!(
                    attempt = attempt,
                    error = %e,
                    backoff_secs = backoff_secs,
                    "Metadata generation failed, retrying after backoff"
                );
                tokio::time::sleep(Duration::from_secs(backoff_secs)).await;
            }
            Err(e) => {
                tracing::error!(
                    attempt = attempt,
                    error = %e,
                    "Final metadata generation attempt failed"
                );
                return Err(e);
            }
        }
    }
    unreachable!()
}

async fn generate_with_timeout(
    repo_path: &str,
    initial_prompt: &str,
) -> anyhow::Result<SessionMetadata> {
    // 60 second timeout for CLI execution to account for network latency,
    // CLI startup time, OAuth validation, and potential API throttling.
    // Increased from 30s to reduce timeout-related failures.
    const TIMEOUT_SECS: u64 = 60;

    tokio::time::timeout(
        Duration::from_secs(TIMEOUT_SECS),
        call_claude_cli(repo_path, initial_prompt),
    )
    .await
    .map_err(|e| {
        tracing::error!(
            timeout_secs = TIMEOUT_SECS,
            repo_path = %repo_path,
            error_type = "timeout",
            error = %e,
            "Claude CLI call timed out"
        );
        anyhow::anyhow!("Claude CLI call timed out after {} seconds: {}", TIMEOUT_SECS, e)
    })?
}

async fn call_claude_cli(repo_path: &str, initial_prompt: &str) -> anyhow::Result<SessionMetadata> {
    // Build the prompt
    let prompt = build_prompt(repo_path, initial_prompt);

    // Build JSON schema for structured output with title, description, and branch name
    let json_schema = r#"{
        "type": "object",
        "properties": {
            "title": {"type": "string"},
            "description": {"type": "string"},
            "branch_name": {"type": "string"}
        },
        "required": ["title", "description", "branch_name"]
    }"#;

    // Build command arguments
    let mut cmd = tokio::process::Command::new("claude");
    cmd.arg("--print")
        .arg("--no-session-persistence")
        .arg("--output-format")
        .arg("json")
        .arg("--json-schema")
        .arg(json_schema)
        .arg("--model")
        .arg("haiku")
        .arg("--max-turns")
        .arg("10")
        .arg("--dangerously-skip-permissions")
        .arg(&prompt);

    // Execute CLI
    tracing::info!("Invoking Claude CLI for name generation");
    let output = cmd.output().await.map_err(|e| {
        if e.kind() == std::io::ErrorKind::NotFound {
            tracing::error!(error_type = "cli_not_found", "Claude CLI not found in PATH");
            anyhow::anyhow!("Claude CLI not found in PATH")
        } else {
            tracing::error!(
                error = %e,
                error_type = "execution_failed",
                "Failed to execute Claude CLI"
            );
            anyhow::anyhow!("Failed to execute Claude CLI: {e}")
        }
    })?;

    // Check exit status
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        let stdout = String::from_utf8_lossy(&output.stdout);
        let exit_code = output.status.code();

        tracing::error!(
            exit_code = ?exit_code,
            error_type = "non_zero_exit",
            stderr = %stderr,
            stdout = %stdout.chars().take(500).collect::<String>(),
            "Claude CLI failed with non-zero exit code"
        );

        anyhow::bail!(
            "Claude CLI failed with exit code {:?}: {}",
            exit_code,
            stderr
        );
    }

    // Parse JSON output with debug logging
    let stdout = String::from_utf8_lossy(&output.stdout);
    tracing::debug!("Claude CLI raw output: {}", stdout);

    let json: serde_json::Value = serde_json::from_str(&stdout).map_err(|e| {
        tracing::error!(
            error = %e,
            error_type = "json_parse_error",
            stdout = %stdout.chars().take(500).collect::<String>(),
            "Failed to parse JSON output from Claude CLI"
        );
        anyhow::anyhow!("Failed to parse JSON output: {e}")
    })?;

    // Check subtype before extracting structured_output
    let subtype = json
        .get("subtype")
        .and_then(|v| v.as_str())
        .unwrap_or("unknown");

    tracing::debug!("Claude CLI response subtype: {}", subtype);

    if subtype != "success" {
        // Special handling for error_max_turns with --json-schema
        if subtype == "error_max_turns" {
            anyhow::bail!(
                "Error: --json-schema was provided but Claude did not return structured_output. \
                 Result subtype: error_max_turns. The conversation reached the maximum turn limit \
                 before completing the structured output request."
            );
        }

        // Generic error for other non-success subtypes
        anyhow::bail!(
            "Claude CLI returned non-success response with subtype: {}",
            subtype
        );
    }

    // Extract the structured_output field (CLI returns wrapper object)
    let structured_output = json.get("structured_output").ok_or_else(|| {
        tracing::error!(
            error_type = "missing_structured_output",
            json_keys = ?json.as_object().map(|o| o.keys().collect::<Vec<_>>()),
            "Missing 'structured_output' field in Claude CLI response"
        );
        anyhow::anyhow!("Missing 'structured_output' field in Claude CLI response")
    })?;

    // Lenient parsing with fallbacks - only branch_name is required
    let title = structured_output
        .get("title")
        .and_then(|v| v.as_str())
        .unwrap_or("New Session").to_owned();

    let description = structured_output
        .get("description")
        .and_then(|v| v.as_str())
        .unwrap_or("AI coding session").to_owned();

    // branch_name is REQUIRED (only field we can't have a good fallback for)
    let branch_name_raw = structured_output
        .get("branch_name")
        .and_then(|v| v.as_str())
        .ok_or_else(|| {
            tracing::error!(
                error_type = "missing_branch_name",
                "Missing 'branch_name' field (required)"
            );
            anyhow::anyhow!("Missing 'branch_name' field (required)")
        })?;

    // Sanitize the branch name
    let branch_name = crate::utils::random::sanitize_branch_name(branch_name_raw);

    // Validate not empty after sanitization
    if branch_name.is_empty() {
        tracing::error!(
            error_type = "empty_branch_name",
            branch_name_raw = %branch_name_raw,
            "Empty branch name after sanitization"
        );
        anyhow::bail!("Empty branch name after sanitization");
    }

    // Log the AI-generated metadata
    tracing::info!(
        title = %title,
        description = %description,
        branch_name = %branch_name,
        "AI generated session metadata"
    );

    Ok(SessionMetadata {
        title,
        description,
        branch_name,
    })
}

fn build_prompt(repo_path: &str, initial_prompt: &str) -> String {
    // Extract repository name from path
    let repo_name = std::path::Path::new(repo_path)
        .file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("unknown");

    // Truncate initial prompt to avoid excessive tokens (keep first 200 chars)
    let truncated_prompt: String = initial_prompt.chars().take(200).collect();

    format!(
        "Analyze this task and generate session metadata:\n\
        Task: {truncated_prompt}\n\
        Repository: {repo_name}\n\n\
        Generate three fields:\n\
        - title: A short title under 10 words describing what will be done\n\
        - description: A brief description in 1-2 sentences explaining the task\n\
        - branch_name: A git branch name with 2-4 words in kebab-case\n\n\
        Be concise and specific."
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_build_prompt() {
        let prompt = build_prompt("/home/user/my-awesome-project", "Fix the login bug");
        assert!(prompt.contains("my-awesome-project"));
        assert!(prompt.contains("Fix the login bug"));
        assert!(prompt.contains("kebab-case"));
    }

    #[test]
    fn test_build_prompt_truncates_long_input() {
        // Use '@' which doesn't appear anywhere in the template
        let long_prompt = "@".repeat(500);
        let prompt = build_prompt("/path/to/repo", &long_prompt);
        // The input should be truncated to 200 chars, not the whole output
        // Verify that the 500-char input was truncated
        let char_count = prompt.chars().filter(|&c| c == '@').count();
        assert_eq!(char_count, 200, "Input should be truncated to 200 chars");
    }

    #[tokio::test]
    async fn test_fallback_when_cli_not_found() {
        // This test will use fallback if claude CLI is not in PATH
        let name = generate_session_name_ai("/tmp/test-repo", "Test prompt").await;
        // Should return "session" or a valid AI-generated name
        assert!(!name.branch_name.is_empty());
    }

    #[test]
    fn test_parse_structured_output_format() {
        // Test that we correctly parse the nested structured_output format
        let json_response = r#"{
            "type": "result",
            "subtype": "success",
            "is_error": false,
            "structured_output": {
                "title": "Test Session Title",
                "description": "Test session description",
                "branch_name": "test-branch"
            },
            "session_id": "test-123",
            "usage": {}
        }"#;

        let json: serde_json::Value = serde_json::from_str(json_response).unwrap();
        let structured_output = json.get("structured_output").unwrap();

        let title = structured_output
            .get("title")
            .and_then(|v| v.as_str())
            .unwrap();
        let description = structured_output
            .get("description")
            .and_then(|v| v.as_str())
            .unwrap();
        let branch_name = structured_output
            .get("branch_name")
            .and_then(|v| v.as_str())
            .unwrap();

        assert_eq!(title, "Test Session Title");
        assert_eq!(description, "Test session description");
        assert_eq!(branch_name, "test-branch");
    }

    #[test]
    fn test_error_max_turns_response_format() {
        // Verify that error_max_turns responses have the expected format
        // Note: This tests response parsing, not the full error handling path
        // which happens in the private call_claude_cli function
        let json_response = r#"{
            "type": "result",
            "subtype": "error_max_turns",
            "is_error": true,
            "session_id": "test-123",
            "usage": {}
        }"#;

        let json: serde_json::Value = serde_json::from_str(json_response).unwrap();
        let subtype = json.get("subtype").and_then(|v| v.as_str()).unwrap();

        // Verify the response has the expected structure
        assert_eq!(subtype, "error_max_turns");
        assert!(json.get("structured_output").is_none());
        assert_eq!(
            json.get("is_error").and_then(serde_json::Value::as_bool),
            Some(true)
        );
    }
}
