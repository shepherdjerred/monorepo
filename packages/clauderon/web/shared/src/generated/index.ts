/*
 Generated by typeshare 1.13.4
*/

/** User account */
export interface AuthUser {
	id: string;
	username: string;
	display_name?: string;
	created_at: string;
}

/** Authentication status response */
export interface AuthStatus {
	/** Whether authentication is required for this instance */
	requires_auth: boolean;
	/** Whether any users exist in the database */
	has_users: boolean;
	/** Currently authenticated user (if any) */
	current_user?: AuthUser;
}

/** Request to browse a directory on the daemon's filesystem */
export interface BrowseDirectoryRequest {
	/** Path to the directory to browse */
	path: string;
}

/** A single directory entry */
export interface DirectoryEntryDto {
	/** Directory name */
	name: string;
	/** Absolute path to the directory */
	path: string;
	/** Whether the directory can be read */
	is_accessible: boolean;
}

/** Response from browsing a directory */
export interface BrowseDirectoryResponse {
	/** Current directory path (normalized absolute path) */
	current_path: string;
	/** Parent directory path (None if at filesystem root) */
	parent_path?: string;
	/** List of subdirectories in the current directory */
	entries: DirectoryEntryDto[];
	/** Error message if path doesn't exist or permission denied */
	error?: string;
}

/** Claude Code usage data for a specific time window */
export interface UsageWindow {
	/** Current usage (e.g., number of requests or tokens) */
	current: number;
	/** Maximum allowed usage for this window */
	limit: number;
	/** Usage as a percentage (0.0 - 1.0) */
	utilization: number;
	/** When this usage window resets (ISO 8601 timestamp) */
	resets_at?: string;
}

/** Error details for usage tracking failures */
export interface UsageError {
	/** Error category (invalid_token, api_error, missing_org_id, etc) */
	error_type: string;
	/** Human-readable error message */
	message: string;
	/** Technical details for debugging */
	details?: string;
	/** Suggested action to resolve the error */
	suggestion?: string;
}

/** Claude Code usage tracking data */
export interface ClaudeUsage {
	/** Organization ID */
	organization_id: string;
	/** Organization name (if available) */
	organization_name?: string;
	/** 5-hour usage window */
	five_hour: UsageWindow;
	/** 7-day usage window */
	seven_day: UsageWindow;
	/** 7-day Sonnet-specific usage window (if applicable) */
	seven_day_sonnet?: UsageWindow;
	/** When this data was last fetched */
	fetched_at: string;
	/** Error information if usage fetch failed */
	error?: UsageError;
}

/** Execution backend type */
export enum BackendType {
	/** Zellij terminal multiplexer */
	Zellij = "Zellij",
	/** Docker container */
	Docker = "Docker",
	/** Kubernetes pod */
	Kubernetes = "Kubernetes",
}

/** AI agent type */
export enum AgentType {
	/** Claude Code CLI */
	ClaudeCode = "ClaudeCode",
	/** OpenAI Codex */
	Codex = "Codex",
	/** Gemini CLI */
	Gemini = "Gemini",
}

/** Model selection for Claude Code agent */
export enum ClaudeModel {
	/** Claude Opus 4.5 (most capable, best for complex workflows) */
	Opus4_5 = "Opus4_5",
	/** Claude Sonnet 4.5 (default, balanced performance for agents and coding) */
	Sonnet4_5 = "Sonnet4_5",
	/** Claude Haiku 4.5 (fastest, optimized for low latency) */
	Haiku4_5 = "Haiku4_5",
	/** Claude Opus 4.1 (focused on agentic tasks and reasoning) */
	Opus4_1 = "Opus4_1",
	/** Claude Opus 4 (previous generation flagship) */
	Opus4 = "Opus4",
	/** Claude Sonnet 4 (previous generation balanced) */
	Sonnet4 = "Sonnet4",
}

/** Model selection for Codex agent */
export enum CodexModel {
	/** GPT-5.2-Codex (default, most advanced for software engineering) */
	Gpt5_2Codex = "Gpt5_2Codex",
	/** GPT-5.2 (most capable for professional knowledge work) */
	Gpt5_2 = "Gpt5_2",
	/** GPT-5.2 Instant (fast variant) */
	Gpt5_2Instant = "Gpt5_2Instant",
	/** GPT-5.2 Thinking (reasoning variant) */
	Gpt5_2Thinking = "Gpt5_2Thinking",
	/** GPT-5.2 Pro (premium variant) */
	Gpt5_2Pro = "Gpt5_2Pro",
	/** GPT-5.1 (previous flagship) */
	Gpt5_1 = "Gpt5_1",
	/** GPT-5.1 Instant (fast variant) */
	Gpt5_1Instant = "Gpt5_1Instant",
	/** GPT-5.1 Thinking (reasoning variant) */
	Gpt5_1Thinking = "Gpt5_1Thinking",
	/** GPT-4.1 (specialized for coding) */
	Gpt4_1 = "Gpt4_1",
	/** o3-mini (small reasoning model for science/math/coding) */
	O3Mini = "O3Mini",
}

/** Model selection for Gemini agent */
export enum GeminiModel {
	/** Gemini 3 Pro (default, state-of-the-art reasoning with 1M token context) */
	Gemini3Pro = "Gemini3Pro",
	/** Gemini 3 Flash (fast frontier-class performance at lower cost) */
	Gemini3Flash = "Gemini3Flash",
	/** Gemini 2.5 Pro (production tier) */
	Gemini2_5Pro = "Gemini2_5Pro",
	/** Gemini 2.0 Flash (previous generation fast model) */
	Gemini2_0Flash = "Gemini2_0Flash",
}

/** Model configuration for a session */
export type SessionModel =
	| { Claude: ClaudeModel }
	| { Codex: CodexModel }
	| { Gemini: GeminiModel };

/** Access mode for proxy filtering */
export enum AccessMode {
	/** Read-only: GET, HEAD, OPTIONS allowed; POST, PUT, DELETE, PATCH blocked */
	ReadOnly = "ReadOnly",
	/** Read-write: All HTTP methods allowed */
	ReadWrite = "ReadWrite",
}

/** Request to create a new session */
export interface CreateSessionRequest {
	/** Path to the repository */
	repo_path: string;
	/** Initial prompt for the AI agent */
	initial_prompt: string;
	/** Execution backend */
	backend: BackendType;
	/** AI agent to use */
	agent: AgentType;
	/**
	 * Optional model selection (must be compatible with selected agent).
	 *
	 * If not specified, the CLI will use its default model.
	 * Examples: "sonnet" (Claude), "gpt-4o" (Codex), "gemini-2.5-pro" (Gemini)
	 */
	model?: SessionModel;
	/** Skip safety checks */
	dangerous_skip_checks: boolean;
	/** Run in print mode (non-interactive, outputs response and exits) */
	print_mode?: boolean;
	/** Start in plan mode */
	plan_mode: boolean;
	/** Access mode for proxy filtering */
	access_mode?: AccessMode;
	/**
	 * Image file paths to attach to initial prompt.
	 * 
	 * Paths should be absolute or relative to the worktree directory.
	 * The TUI does not currently provide a file picker for selecting images -
	 * this field is primarily used when creating sessions via the API.
	 * Images will be passed to Claude Code using the `--image` flag.
	 */
	images?: string[];
	/**
	 * Optional: Custom container image (overrides backend default).
	 * 
	 * Format: `[registry/]repository[:tag]`
	 * Example: `"ghcr.io/user/custom-dev:latest"`
	 * 
	 * Image must meet requirements: claude/codex CLI, bash, curl, git (recommended).
	 * See docs/IMAGE_COMPATIBILITY.md for full requirements.
	 */
	container_image?: string;
	/**
	 * Optional: Image pull policy.
	 * 
	 * Controls when to pull the container image:
	 * - `"always"`: Always pull latest version
	 * - `"if-not-present"`: Pull only if not cached (default)
	 * - `"never"`: Never pull, use local cache only
	 */
	pull_policy?: string;
	/**
	 * Optional: CPU limit for the container.
	 * 
	 * Format:
	 * - Docker: Decimal cores (e.g., `"2.0"`, `"0.5"`)
	 * - Kubernetes: Millicores or cores (e.g., `"2000m"`, `"2"`)
	 */
	cpu_limit?: string;
	/**
	 * Optional: Memory limit for the container.
	 * 
	 * Format: Number with suffix
	 * - Docker: `"2g"` (2 gigabytes), `"512m"` (512 megabytes)
	 * - Kubernetes: `"2Gi"` (2 gibibytes), `"512Mi"` (512 mebibytes)
	 */
	memory_limit?: string;
}

/** Credential availability status */
export interface CredentialStatus {
	/** Human-readable credential name (e.g., "GitHub", "Anthropic") */
	name: string;
	/** Service identifier for updates (e.g., "github", "anthropic") */
	service_id: string;
	/** Whether the credential is available */
	available: boolean;
	/** Source of credential if available ("environment" or "file") */
	source?: string;
	/** Whether the credential is readonly (from environment) */
	readonly: boolean;
	/** Optional masked preview like "ghp_****...abc123" */
	masked_value?: string;
}

/** Request to finish passkey authentication */
export interface LoginFinishRequest {
	username: string;
	challenge_id: string;
	credential: any;
}

/** Response from login finish */
export interface LoginFinishResponse {
	user: AuthUser;
}

/** Request to start passkey authentication */
export interface LoginStartRequest {
	username: string;
}

/** Response from login start */
export interface LoginStartResponse {
	challenge_id: string;
	options: any;
}

/** Progress step during session creation */
export interface ProgressStep {
	/** Current step number (1-indexed) */
	step: number;
	/** Total number of steps */
	total: number;
	/** Description of current step */
	message: string;
}

/** Proxy status information */
export interface ProxyStatus {
	/** Proxy name (e.g., "HTTP Auth Proxy", "Kubernetes Proxy") */
	name: string;
	/** Port number the proxy is running on */
	port: number;
	/** Whether the proxy is currently active */
	active: boolean;
	/** Proxy type ("global" or "session-specific") */
	proxy_type: string;
}

/** Recent repository entry with timestamp */
export interface RecentRepoDto {
	/** Path to the repository (git root) */
	repo_path: string;
	/** Subdirectory path relative to git root (empty string if at root) */
	subdirectory: string;
	/** When this repository was last used (ISO 8601 timestamp) */
	last_used: string;
}

/** Serializable reconcile report for API responses */
export interface ReconcileReportDto {
	/** Sessions with missing git worktrees */
	missing_worktrees: string[];
	/** Sessions with missing backend resources */
	missing_backends: string[];
	/** Orphaned backend resources */
	orphaned_backends: string[];
	/** Sessions that were successfully recreated */
	recreated: string[];
	/** Sessions that failed to be recreated */
	recreation_failed: string[];
	/** Sessions that exceeded max reconcile attempts */
	gave_up: string[];
}

/** Request to finish passkey registration */
export interface RegistrationFinishRequest {
	username: string;
	challenge_id: string;
	credential: any;
	device_name?: string;
}

/** Response from registration finish */
export interface RegistrationFinishResponse {
	user: AuthUser;
}

/** Request to start passkey registration */
export interface RegistrationStartRequest {
	username: string;
	display_name?: string;
}

/** Response from registration start */
export interface RegistrationStartResponse {
	challenge_id: string;
	options: any;
}

/** Session lifecycle status */
export enum SessionStatus {
	/** Session is being created */
	Creating = "Creating",
	/** Session is being deleted */
	Deleting = "Deleting",
	/** Agent is actively working */
	Running = "Running",
	/** Agent is waiting for input */
	Idle = "Idle",
	/** Work is done, PR merged */
	Completed = "Completed",
	/** Something went wrong */
	Failed = "Failed",
	/** User archived the session */
	Archived = "Archived",
}

/** PR check status */
export enum CheckStatus {
	/** Checks are pending */
	Pending = "Pending",
	/** All checks are passing */
	Passing = "Passing",
	/** Some checks are failing */
	Failing = "Failing",
	/** PR is ready to merge */
	Mergeable = "Mergeable",
	/** PR has been merged */
	Merged = "Merged",
}

/** Claude agent working status */
export enum ClaudeWorkingStatus {
	/** Unknown state (no hooks configured or no data yet) */
	Unknown = "Unknown",
	/** Claude is actively working (PreToolUse hook triggered) */
	Working = "Working",
	/** Waiting for permission approval (PermissionRequest hook) */
	WaitingApproval = "WaitingApproval",
	/** Waiting for user input (idle_prompt notification or Stop hook) */
	WaitingInput = "WaitingInput",
	/** Agent is idle (60+ seconds without activity) */
	Idle = "Idle",
}

/** Represents a single AI coding session */
export interface Session {
	/** Unique identifier */
	id: string;
	/** Human-friendly name (user-provided + random suffix) */
	name: string;
	/** AI-generated title for display (optional, falls back to name) */
	title?: string;
	/** AI-generated description of the task (optional) */
	description?: string;
	/** Current status of the session */
	status: SessionStatus;
	/** Execution backend */
	backend: BackendType;
	/** AI agent running in this session */
	agent: AgentType;
	/** AI model for this session (None for sessions created before model selection was added) */
	model?: SessionModel;
	/** Path to the source repository */
	repo_path: string;
	/** Path to the git worktree */
	worktree_path: string;
	/**
	 * Subdirectory path relative to git root (empty if at root)
	 * Example: "packages/clauderon" for a subdirectory session
	 */
	subdirectory: string;
	/** Git branch name */
	branch_name: string;
	/** Backend-specific identifier (zellij session name, docker container id, or kubernetes pod name) */
	backend_id?: string;
	/** Initial prompt given to the AI agent */
	initial_prompt: string;
	/** Whether to skip safety checks */
	dangerous_skip_checks: boolean;
	/** URL of the associated pull request */
	pr_url?: string;
	/** Status of PR checks */
	pr_check_status?: CheckStatus;
	/** Current Claude agent working status (from hooks) */
	claude_status: ClaudeWorkingStatus;
	/** Timestamp of last Claude status update */
	claude_status_updated_at: string;
	/** Whether the session branch has merge conflicts with main */
	merge_conflict: boolean;
	/** Whether the worktree has uncommitted changes (dirty working tree) */
	worktree_dirty: boolean;
	/** Access mode for proxy filtering */
	access_mode: AccessMode;
	/** Port for session-specific HTTP proxy (Docker only) */
	proxy_port?: number;
	/** Path to Claude Code's session history file (.jsonl) */
	history_file_path: string;
	/** Number of times we've attempted to recreate the container */
	reconcile_attempts: number;
	/** Last reconciliation error message */
	last_reconcile_error?: string;
	/** When the last reconciliation attempt occurred */
	last_reconcile_at: string;
	/** Error message if status is Failed (None otherwise) */
	error_message?: string;
	/** Current operation progress (for Creating/Deleting states) */
	progress?: ProgressStep;
	/** When the session was created */
	created_at: string;
	/** When the session was last updated */
	updated_at: string;
}

/** System status response including credentials and proxies */
export interface SystemStatus {
	/** List of credential statuses */
	credentials: CredentialStatus[];
	/** List of proxy statuses */
	proxies: ProxyStatus[];
	/** Total number of active sessions with proxies */
	active_session_proxies: number;
	/** Claude Code usage tracking (if available) */
	claude_usage?: ClaudeUsage;
}

/** Request to update a credential */
export interface UpdateCredentialRequest {
	/** Service identifier (e.g., "github", "anthropic") */
	service_id: string;
	/** The credential token/key value */
	value: string;
}

/** Response from uploading an image file */
export interface UploadResponse {
	/** Absolute path to the uploaded file */
	path: string;
	/** Size of the uploaded file in bytes */
	size: number;
}

/** User's passkey credential */
export interface UserPasskey {
	id: string;
	user_id: string;
	device_name?: string;
	created_at: string;
}

/** Current state of an AI agent */
export enum AgentState {
	/** Agent is actively working on a task */
	Working = "Working",
	/** Agent is waiting for user input */
	Idle = "Idle",
	/** Agent state is unknown */
	Unknown = "Unknown",
}

/** Real-time events from the server */
export type Event = 
	/** A new session was created */
	| { type: "SessionCreated", payload: Session }
	/** A session was updated */
	| { type: "SessionUpdated", payload: Session }
	/** A session was deleted */
	| { type: "SessionDeleted", payload: {
	id: string;
}}
	/** Session status changed */
	| { type: "StatusChanged", payload: {
	id: string;
	old: SessionStatus;
	new: SessionStatus;
}}
	/** Progress update during async operation */
	| { type: "SessionProgress", payload: {
	id: string;
	progress: ProgressStep;
}}
	/** Session operation failed */
	| { type: "SessionFailed", payload: {
	id: string;
	error: string;
}};

/** Types of events that can occur */
export type EventType = 
	/** A new session was created */
	| { type: "SessionCreated", payload: {
	name: string;
	repo_path: string;
	backend: BackendType;
	initial_prompt: string;
}}
	/** Session status changed */
	| { type: "StatusChanged", payload: {
	old_status: SessionStatus;
	new_status: SessionStatus;
}}
	/** Backend ID was set */
	| { type: "BackendIdSet", payload: {
	backend_id: string;
}}
	/** PR was linked to session */
	| { type: "PrLinked", payload: {
	pr_url: string;
}}
	/** PR check status changed */
	| { type: "CheckStatusChanged", payload: {
	old_status?: CheckStatus;
	new_status: CheckStatus;
}}
	/** Claude working status changed */
	| { type: "ClaudeStatusChanged", payload: {
	old_status: ClaudeWorkingStatus;
	new_status: ClaudeWorkingStatus;
}}
	/** Merge conflict status changed */
	| { type: "ConflictStatusChanged", payload: {
	has_conflict: boolean;
}}
	/** Working tree status changed (dirty/clean) */
	| { type: "WorktreeStatusChanged", payload: {
	is_dirty: boolean;
}}
	/** Session was archived */
	| { type: "SessionArchived", payload?: undefined }
	/** Session was deleted */
	| { type: "SessionDeleted", payload: {
	reason?: string;
}}
	/** Session was restored from archive */
	| { type: "SessionRestored", payload?: undefined };

/** Request types for the API */
export type Request = 
	/** List all sessions */
	| { type: "ListSessions", payload?: undefined }
	/** Get a specific session by ID or name */
	| { type: "GetSession", payload: {
	id: string;
}}
	/** Create a new session */
	| { type: "CreateSession", payload: CreateSessionRequest }
	/** Delete a session */
	| { type: "DeleteSession", payload: {
	id: string;
}}
	/** Archive a session */
	| { type: "ArchiveSession", payload: {
	id: string;
}}
	/** Unarchive a session */
	| { type: "UnarchiveSession", payload: {
	id: string;
}}
	/** Get the attach command for a session */
	| { type: "AttachSession", payload: {
	id: string;
}}
	/** Update session access mode */
	| { type: "UpdateAccessMode", payload: {
	id: string;
	access_mode: AccessMode;
}}
	/** Reconcile state with reality */
	| { type: "Reconcile", payload?: undefined }
	/** Subscribe to real-time updates */
	| { type: "Subscribe", payload?: undefined }
	/** Get recent repositories */
	| { type: "GetRecentRepos", payload?: undefined }
	/** Send a prompt to a session (for hotkey triggers) */
	| { type: "SendPrompt", payload: {
	session: string;
	prompt: string;
}}
	/** Get session ID by name (for hook scripts) */
	| { type: "GetSessionIdByName", payload: {
	name: string;
}}
	/** Refresh a session (pull latest image and recreate container) */
	| { type: "RefreshSession", payload: {
	id: string;
}};

/** Response types for the API */
export type Response = 
	/** List of sessions */
	| { type: "Sessions", payload: Session[] }
	/** A single session */
	| { type: "Session", payload: Session }
	/** Progress update during long operation */
	| { type: "Progress", payload: ProgressStep }
	/** Session created successfully */
	| { type: "Created", payload: {
	id: string;
	warnings?: string[];
}}
	/** Session deleted successfully */
	| { type: "Deleted", payload?: undefined }
	/** Session archived successfully */
	| { type: "Archived", payload?: undefined }
	/** Session unarchived successfully */
	| { type: "Unarchived", payload?: undefined }
	/** Session refreshed successfully */
	| { type: "Refreshed", payload?: undefined }
	/** Command to attach to a session */
	| { type: "AttachReady", payload: {
	command: string[];
}}
	/** Reconciliation report */
	| { type: "ReconcileReport", payload: ReconcileReportDto }
	/** Subscription confirmed */
	| { type: "Subscribed", payload?: undefined }
	/** List of recent repositories with timestamps */
	| { type: "RecentRepos", payload: RecentRepoDto[] }
	/** Access mode updated successfully */
	| { type: "AccessModeUpdated", payload?: undefined }
	/** Session ID returned */
	| { type: "SessionId", payload: {
	session_id: string;
}}
	/** Generic success response */
	| { type: "Ok", payload?: undefined }
	/** Error response */
	| { type: "Error", payload: {
	code: string;
	message: string;
}};

