use std::time::Duration;

/// Metadata generated by AI for a new session
#[derive(Debug, Clone)]
pub struct SessionMetadata {
    /// Short title (under 10 words) for display in UI
    pub title: String,

    /// Brief description (1-2 sentences) explaining the task
    pub description: String,

    /// Sanitized git branch name (kebab-case, 2-4 words)
    pub branch_name: String,
}

impl Default for SessionMetadata {
    fn default() -> Self {
        Self {
            title: "New Session".to_string(),
            description: "AI coding session".to_string(),
            branch_name: "session".to_string(),
        }
    }
}

/// Generate session metadata using the Claude CLI
///
/// This function invokes the `claude` CLI tool with structured JSON output
/// to generate title, description, and branch name based on the repository path
/// and initial prompt.
///
/// # Arguments
/// * `repo_path` - Path to the repository
/// * `initial_prompt` - The user's initial prompt/task description
///
/// # Returns
/// Returns SessionMetadata with title, description, and sanitized branch name.
/// Falls back to defaults if the CLI is not available, fails to execute, or returns invalid output.
///
/// # Example
/// ```ignore
/// let metadata = generate_session_name_ai("/home/user/my-repo", "Fix login bug").await;
/// // Returns SessionMetadata { title: "Fix login bug", description: "...", branch_name: "fix-login-bug" }
/// ```
pub async fn generate_session_name_ai(repo_path: &str, initial_prompt: &str) -> SessionMetadata {
    match generate_with_timeout(repo_path, initial_prompt).await {
        Ok(metadata) => {
            tracing::info!(
                repo = %repo_path,
                title = %metadata.title,
                branch_name = %metadata.branch_name,
                "AI-generated session metadata"
            );
            metadata
        }
        Err(e) => {
            tracing::warn!(
                error = %e,
                "Failed to generate AI metadata, using fallback"
            );
            SessionMetadata::default()
        }
    }
}

async fn generate_with_timeout(
    repo_path: &str,
    initial_prompt: &str,
) -> anyhow::Result<SessionMetadata> {
    // 30 second timeout for CLI execution to account for network latency,
    // CLI startup time, OAuth validation, and potential API throttling
    tokio::time::timeout(
        Duration::from_secs(30),
        call_claude_cli(repo_path, initial_prompt),
    )
    .await
    .map_err(|_| anyhow::anyhow!("Claude CLI call timed out"))?
}

async fn call_claude_cli(repo_path: &str, initial_prompt: &str) -> anyhow::Result<SessionMetadata> {
    // Build the prompt
    let prompt = build_prompt(repo_path, initial_prompt);

    // Build JSON schema for structured output with title, description, and branch name
    let json_schema = r#"{
        "type": "object",
        "properties": {
            "title": {"type": "string"},
            "description": {"type": "string"},
            "branch_name": {"type": "string"}
        },
        "required": ["title", "description", "branch_name"]
    }"#;

    // Build command arguments
    let mut cmd = tokio::process::Command::new("claude");
    cmd.arg("--print")
        .arg("--no-session-persistence")
        .arg("--output-format")
        .arg("json")
        .arg("--json-schema")
        .arg(json_schema)
        .arg("--model")
        .arg("haiku")
        .arg("--max-turns")
        .arg("10")
        .arg("--dangerously-skip-permissions")
        .arg(&prompt);

    // Execute CLI
    tracing::debug!("Invoking Claude CLI for name generation");
    let output = cmd.output().await.map_err(|e| {
        if e.kind() == std::io::ErrorKind::NotFound {
            anyhow::anyhow!("Claude CLI not found in PATH")
        } else {
            anyhow::anyhow!("Failed to execute Claude CLI: {e}")
        }
    })?;

    // Check exit status
    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!(
            "Claude CLI failed with exit code {:?}: {}",
            output.status.code(),
            stderr
        );
    }

    // Parse JSON output with debug logging
    let stdout = String::from_utf8_lossy(&output.stdout);
    tracing::debug!("Claude CLI raw output: {}", stdout);

    let json: serde_json::Value = serde_json::from_str(&stdout)
        .map_err(|e| anyhow::anyhow!("Failed to parse JSON output: {e}"))?;

    // Check subtype before extracting structured_output
    let subtype = json
        .get("subtype")
        .and_then(|v| v.as_str())
        .unwrap_or("unknown");

    tracing::debug!("Claude CLI response subtype: {}", subtype);

    if subtype != "success" {
        // Special handling for error_max_turns with --json-schema
        if subtype == "error_max_turns" {
            anyhow::bail!(
                "Error: --json-schema was provided but Claude did not return structured_output. \
                 Result subtype: error_max_turns. The conversation reached the maximum turn limit \
                 before completing the structured output request."
            );
        }

        // Generic error for other non-success subtypes
        anyhow::bail!(
            "Claude CLI returned non-success response with subtype: {}",
            subtype
        );
    }

    // Extract the structured_output field (CLI returns wrapper object)
    let structured_output = json.get("structured_output").ok_or_else(|| {
        anyhow::anyhow!("Missing 'structured_output' field in Claude CLI response")
    })?;

    // Lenient parsing with fallbacks - only branch_name is required
    let title = structured_output
        .get("title")
        .and_then(|v| v.as_str())
        .unwrap_or("New Session")
        .to_string();

    let description = structured_output
        .get("description")
        .and_then(|v| v.as_str())
        .unwrap_or("AI coding session")
        .to_string();

    // branch_name is REQUIRED (only field we can't have a good fallback for)
    let branch_name_raw = structured_output
        .get("branch_name")
        .and_then(|v| v.as_str())
        .ok_or_else(|| anyhow::anyhow!("Missing 'branch_name' field (required)"))?;

    // Sanitize the branch name
    let branch_name = crate::utils::random::sanitize_branch_name(branch_name_raw);

    // Validate not empty after sanitization
    if branch_name.is_empty() {
        anyhow::bail!("Empty branch name after sanitization");
    }

    // Log the AI-generated metadata
    tracing::info!(
        title = %title,
        description = %description,
        branch_name = %branch_name,
        "AI generated session metadata"
    );

    Ok(SessionMetadata {
        title,
        description,
        branch_name,
    })
}

fn build_prompt(repo_path: &str, initial_prompt: &str) -> String {
    // Extract repository name from path
    let repo_name = std::path::Path::new(repo_path)
        .file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("unknown");

    // Truncate initial prompt to avoid excessive tokens (keep first 200 chars)
    let truncated_prompt: String = initial_prompt.chars().take(200).collect();

    format!(
        "Analyze this task and generate session metadata:\n\
        Task: {truncated_prompt}\n\
        Repository: {repo_name}\n\n\
        Generate three fields:\n\
        - title: A short title under 10 words describing what will be done\n\
        - description: A brief description in 1-2 sentences explaining the task\n\
        - branch_name: A git branch name with 2-4 words in kebab-case\n\n\
        Be concise and specific."
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_build_prompt() {
        let prompt = build_prompt("/home/user/my-awesome-project", "Fix the login bug");
        assert!(prompt.contains("my-awesome-project"));
        assert!(prompt.contains("Fix the login bug"));
        assert!(prompt.contains("kebab-case"));
    }

    #[test]
    fn test_build_prompt_truncates_long_input() {
        // Use '@' which doesn't appear anywhere in the template
        let long_prompt = "@".repeat(500);
        let prompt = build_prompt("/path/to/repo", &long_prompt);
        // The input should be truncated to 200 chars, not the whole output
        // Verify that the 500-char input was truncated
        let char_count = prompt.chars().filter(|&c| c == '@').count();
        assert_eq!(char_count, 200, "Input should be truncated to 200 chars");
    }

    #[tokio::test]
    async fn test_fallback_when_cli_not_found() {
        // This test will use fallback if claude CLI is not in PATH
        let name = generate_session_name_ai("/tmp/test-repo", "Test prompt").await;
        // Should return "session" or a valid AI-generated name
        assert!(!name.branch_name.is_empty());
    }

    #[test]
    fn test_parse_structured_output_format() {
        // Test that we correctly parse the nested structured_output format
        let json_response = r#"{
            "type": "result",
            "subtype": "success",
            "is_error": false,
            "structured_output": {
                "title": "Test Session Title",
                "description": "Test session description",
                "branch_name": "test-branch"
            },
            "session_id": "test-123",
            "usage": {}
        }"#;

        let json: serde_json::Value = serde_json::from_str(json_response).unwrap();
        let structured_output = json.get("structured_output").unwrap();

        let title = structured_output
            .get("title")
            .and_then(|v| v.as_str())
            .unwrap();
        let description = structured_output
            .get("description")
            .and_then(|v| v.as_str())
            .unwrap();
        let branch_name = structured_output
            .get("branch_name")
            .and_then(|v| v.as_str())
            .unwrap();

        assert_eq!(title, "Test Session Title");
        assert_eq!(description, "Test session description");
        assert_eq!(branch_name, "test-branch");
    }

    #[test]
    fn test_error_max_turns_response_format() {
        // Verify that error_max_turns responses have the expected format
        // Note: This tests response parsing, not the full error handling path
        // which happens in the private call_claude_cli function
        let json_response = r#"{
            "type": "result",
            "subtype": "error_max_turns",
            "is_error": true,
            "session_id": "test-123",
            "usage": {}
        }"#;

        let json: serde_json::Value = serde_json::from_str(json_response).unwrap();
        let subtype = json.get("subtype").and_then(|v| v.as_str()).unwrap();

        // Verify the response has the expected structure
        assert_eq!(subtype, "error_max_turns");
        assert!(json.get("structured_output").is_none());
        assert_eq!(json.get("is_error").and_then(serde_json::Value::as_bool), Some(true));
    }
}
