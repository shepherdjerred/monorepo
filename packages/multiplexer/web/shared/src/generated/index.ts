/*
 Generated by typeshare 1.13.4
*/

/** Execution backend type */
export enum BackendType {
	/** Zellij terminal multiplexer */
	Zellij = "Zellij",
	/** Docker container */
	Docker = "Docker",
}

/** AI agent type */
export enum AgentType {
	/** Claude Code CLI */
	ClaudeCode = "ClaudeCode",
	/** `OpenAI` Codex */
	Codex = "Codex",
}

/** Access mode for proxy filtering */
export enum AccessMode {
	/** Read-only: GET, HEAD, OPTIONS allowed; POST, PUT, DELETE, PATCH blocked */
	ReadOnly = "ReadOnly",
	/** Read-write: All HTTP methods allowed */
	ReadWrite = "ReadWrite",
}

/** Request to create a new session */
export interface CreateSessionRequest {
	/** Session name (a random suffix will be added) */
	name: string;
	/** Path to the repository */
	repo_path: string;
	/** Initial prompt for the AI agent */
	initial_prompt: string;
	/** Execution backend */
	backend: BackendType;
	/** AI agent to use */
	agent: AgentType;
	/** Skip safety checks */
	dangerous_skip_checks: boolean;
	/** Run in print mode (non-interactive, outputs response and exits) */
	print_mode?: boolean;
	/** Start in plan mode */
	plan_mode: boolean;
	/** Access mode for proxy filtering */
	access_mode?: AccessMode;
	/**
	 * Image file paths to attach to initial prompt.
	 * 
	 * Paths should be absolute or relative to the worktree directory.
	 * The TUI does not currently provide a file picker for selecting images -
	 * this field is primarily used when creating sessions via the API.
	 * Images will be passed to Claude Code using the `--image` flag.
	 */
	images?: string[];
}

/** Progress step during session creation */
export interface ProgressStep {
	/** Current step number (1-indexed) */
	step: number;
	/** Total number of steps */
	total: number;
	/** Description of current step */
	message: string;
}

/** Recent repository entry with timestamp */
export interface RecentRepoDto {
	/** Path to the repository */
	repo_path: string;
	/** When this repository was last used (ISO 8601 timestamp) */
	last_used: string;
}

/** Serializable reconcile report for API responses */
export interface ReconcileReportDto {
	/** Sessions with missing git worktrees */
	missing_worktrees: string[];
	/** Sessions with missing backend resources */
	missing_backends: string[];
	/** Orphaned backend resources */
	orphaned_backends: string[];
}

/** Session lifecycle status */
export enum SessionStatus {
	/** Session is being created */
	Creating = "Creating",
	/** Agent is actively working */
	Running = "Running",
	/** Agent is waiting for input */
	Idle = "Idle",
	/** Work is done, PR merged */
	Completed = "Completed",
	/** Something went wrong */
	Failed = "Failed",
	/** User archived the session */
	Archived = "Archived",
}

/** PR check status */
export enum CheckStatus {
	/** Checks are pending */
	Pending = "Pending",
	/** All checks are passing */
	Passing = "Passing",
	/** Some checks are failing */
	Failing = "Failing",
	/** PR is ready to merge */
	Mergeable = "Mergeable",
	/** PR has been merged */
	Merged = "Merged",
}

/** Claude agent working status */
export enum ClaudeWorkingStatus {
	/** Unknown state (no hooks configured or no data yet) */
	Unknown = "Unknown",
	/** Claude is actively working (PreToolUse hook triggered) */
	Working = "Working",
	/** Waiting for permission approval (PermissionRequest hook) */
	WaitingApproval = "WaitingApproval",
	/** Waiting for user input (idle_prompt notification or Stop hook) */
	WaitingInput = "WaitingInput",
	/** Agent is idle (60+ seconds without activity) */
	Idle = "Idle",
}

/** Represents a single AI coding session */
export interface Session {
	/** Unique identifier */
	id: string;
	/** Human-friendly name (user-provided + random suffix) */
	name: string;
	/** Current status of the session */
	status: SessionStatus;
	/** Execution backend */
	backend: BackendType;
	/** AI agent running in this session */
	agent: AgentType;
	/** Path to the source repository */
	repo_path: string;
	/** Path to the git worktree */
	worktree_path: string;
	/** Git branch name */
	branch_name: string;
	/** Backend-specific identifier (zellij session name or docker container id) */
	backend_id?: string;
	/** Initial prompt given to the AI agent */
	initial_prompt: string;
	/** Whether to skip safety checks */
	dangerous_skip_checks: boolean;
	/** URL of the associated pull request */
	pr_url?: string;
	/** Status of PR checks */
	pr_check_status?: CheckStatus;
	/** Current Claude agent working status (from hooks) */
	claude_status: ClaudeWorkingStatus;
	/** Timestamp of last Claude status update */
	claude_status_updated_at: string;
	/** Access mode for proxy filtering */
	access_mode: AccessMode;
	/** Port for session-specific HTTP proxy (Docker only) */
	proxy_port?: number;
	/** When the session was created */
	created_at: string;
	/** When the session was last updated */
	updated_at: string;
}

/** Current state of an AI agent */
export enum AgentState {
	/** Agent is actively working on a task */
	Working = "Working",
	/** Agent is waiting for user input */
	Idle = "Idle",
	/** Agent state is unknown */
	Unknown = "Unknown",
}

/** Real-time events from the server */
export type Event = 
	/** A new session was created */
	| { type: "SessionCreated", payload: Session }
	/** A session was updated */
	| { type: "SessionUpdated", payload: Session }
	/** A session was deleted */
	| { type: "SessionDeleted", payload: {
	id: string;
}}
	/** Session status changed */
	| { type: "StatusChanged", payload: {
	id: string;
	old: SessionStatus;
	new: SessionStatus;
}};

/** Types of events that can occur */
export type EventType = 
	/** A new session was created */
	| { type: "SessionCreated", payload: {
	name: string;
	repo_path: string;
	backend: BackendType;
	initial_prompt: string;
}}
	/** Session status changed */
	| { type: "StatusChanged", payload: {
	old_status: SessionStatus;
	new_status: SessionStatus;
}}
	/** Backend ID was set */
	| { type: "BackendIdSet", payload: {
	backend_id: string;
}}
	/** PR was linked to session */
	| { type: "PrLinked", payload: {
	pr_url: string;
}}
	/** PR check status changed */
	| { type: "CheckStatusChanged", payload: {
	old_status?: CheckStatus;
	new_status: CheckStatus;
}}
	/** Claude working status changed */
	| { type: "ClaudeStatusChanged", payload: {
	old_status: ClaudeWorkingStatus;
	new_status: ClaudeWorkingStatus;
}}
	/** Session was archived */
	| { type: "SessionArchived", payload?: undefined }
	/** Session was deleted */
	| { type: "SessionDeleted", payload: {
	reason?: string;
}}
	/** Session was restored from archive */
	| { type: "SessionRestored", payload?: undefined };

/** Request types for the API */
export type Request = 
	/** List all sessions */
	| { type: "ListSessions", payload?: undefined }
	/** Get a specific session by ID or name */
	| { type: "GetSession", payload: {
	id: string;
}}
	/** Create a new session */
	| { type: "CreateSession", payload: CreateSessionRequest }
	/** Delete a session */
	| { type: "DeleteSession", payload: {
	id: string;
}}
	/** Archive a session */
	| { type: "ArchiveSession", payload: {
	id: string;
}}
	/** Get the attach command for a session */
	| { type: "AttachSession", payload: {
	id: string;
}}
	/** Update session access mode */
	| { type: "UpdateAccessMode", payload: {
	id: string;
	access_mode: AccessMode;
}}
	/** Reconcile state with reality */
	| { type: "Reconcile", payload?: undefined }
	/** Subscribe to real-time updates */
	| { type: "Subscribe", payload?: undefined }
	/** Get recent repositories */
	| { type: "GetRecentRepos", payload?: undefined }
	/** Send a prompt to a session (for hotkey triggers) */
	| { type: "SendPrompt", payload: {
	session: string;
	prompt: string;
}}
	/** Get session ID by name (for hook scripts) */
	| { type: "GetSessionIdByName", payload: {
	name: string;
}};

/** Response types for the API */
export type Response = 
	/** List of sessions */
	| { type: "Sessions", payload: Session[] }
	/** A single session */
	| { type: "Session", payload: Session }
	/** Progress update during long operation */
	| { type: "Progress", payload: ProgressStep }
	/** Session created successfully */
	| { type: "Created", payload: {
	id: string;
	warnings?: string[];
}}
	/** Session deleted successfully */
	| { type: "Deleted", payload?: undefined }
	/** Session archived successfully */
	| { type: "Archived", payload?: undefined }
	/** Command to attach to a session */
	| { type: "AttachReady", payload: {
	command: string[];
}}
	/** Reconciliation report */
	| { type: "ReconcileReport", payload: ReconcileReportDto }
	/** Subscription confirmed */
	| { type: "Subscribed", payload?: undefined }
	/** List of recent repositories with timestamps */
	| { type: "RecentRepos", payload: RecentRepoDto[] }
	/** Access mode updated successfully */
	| { type: "AccessModeUpdated", payload?: undefined }
	/** Session ID returned */
	| { type: "SessionId", payload: {
	session_id: string;
}}
	/** Generic success response */
	| { type: "Ok", payload?: undefined }
	/** Error response */
	| { type: "Error", payload: {
	code: string;
	message: string;
}};

