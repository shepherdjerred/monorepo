import type { Directory, Secret } from "@dagger.io/dagger";
import { dag } from "@dagger.io/dagger";

const REPO = "shepherdjerred/monorepo";
const README_BRANCH = "auto/update-readmes";
const README_COMMIT = "docs: auto-update READMEs";
const README_PR_TITLE = "docs: auto-update READMEs";
const README_PR_BODY = "Automated README updates generated by cog + Codex CLI in Dagger.";
const BUN_VERSION = "1.3.6";

export type UpdateReadmesOptions = {
  source: Directory;
  githubToken: Secret;
  openaiApiKey: Secret;
  baseBranch: string;
};

/**
 * Update README files via cog and open/update a PR.
 * Runs fully inside Dagger so GitHub Actions only orchestrates the call.
 */
export async function updateReadmes(options: UpdateReadmesOptions): Promise<string> {
  const { source, githubToken, openaiApiKey, baseBranch } = options;

  const runScript = `#!/usr/bin/env bash
set -euo pipefail

REPO="${REPO}"
BASE_BRANCH="${baseBranch}"
BRANCH="${README_BRANCH}"

git config --global user.name "github-actions[bot]"
git config --global user.email "github-actions[bot]@users.noreply.github.com"
git config --global core.hooksPath /dev/null

cd /workspace/source
git checkout "$BASE_BRANCH"
git remote set-url origin "https://x-access-token:\${GH_TOKEN}@github.com/$REPO.git"

# Keep tools local to this repo run.
python3 -m pip install --break-system-packages cogapp >/tmp/pip.log 2>&1

# Clear cached summaries so every run regenerates from current prompt/rules.
git rm -f --ignore-unmatch -- "packages/*/_summary.md" "practice/*/_summary.md" "archive/*/_summary.md"

# Regenerate README content (cog blocks call Codex CLI).
python3 -m cogapp -r README.md practice/README.md archive/README.md

if git diff --quiet; then
  echo "No README changes detected."
  exit 0
fi

git checkout -B "$BRANCH"
git add README.md practice/README.md archive/README.md
while IFS= read -r summary_file; do
  [ -n "$summary_file" ] && git add "$summary_file"
done < <(git ls-files -m -o --exclude-standard -- "packages/*/_summary.md" "practice/*/_summary.md" "archive/*/_summary.md")
LEFTHOOK=0 HUSKY=0 git commit -m "${README_COMMIT}"
git push --force origin "$BRANCH"

OPEN_PR_COUNT="$(gh pr list --repo "$REPO" --state open --head "$BRANCH" --json number --jq 'length')"
if [ "$OPEN_PR_COUNT" -eq 0 ]; then
  gh pr create \
    --repo "$REPO" \
    --title "${README_PR_TITLE}" \
    --body "${README_PR_BODY}" \
    --head "$BRANCH" \
    --base "$BASE_BRANCH"
else
  echo "Open PR already exists for $BRANCH"
fi
`;

  const container = dag
    .container()
    .from(`oven/bun:${BUN_VERSION}-debian`)
    .withMountedCache("/var/cache/apt", dag.cacheVolume(`apt-cache-bun-${BUN_VERSION}-readme`))
    .withMountedCache("/var/lib/apt", dag.cacheVolume(`apt-lib-bun-${BUN_VERSION}-readme`))
    .withMountedCache("/root/.bun/install/cache", dag.cacheVolume("bun-cache"))
    .withExec(["apt-get", "update"])
    .withExec(["apt-get", "install", "-y", "git", "curl", "python3", "python3-pip"])
    .withExec([
      "sh",
      "-c",
      "curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg",
    ])
    .withExec([
      "sh",
      "-c",
      'echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" > /etc/apt/sources.list.d/github-cli.list',
    ])
    .withExec(["apt-get", "update"])
    .withExec(["apt-get", "install", "-y", "gh"])
    // Allow codex CLI runs from cog blocks to read project files without prompts.
    .withEnvVariable("CODEX_SANDBOX_MODE", "read-only")
    .withEnvVariable("CODEX_ASK_FOR_APPROVAL", "never")
    .withSecretVariable("GH_TOKEN", githubToken)
    .withSecretVariable("OPENAI_API_KEY", openaiApiKey)
    // codex exec in CI expects CODEX_API_KEY.
    .withSecretVariable("CODEX_API_KEY", openaiApiKey)
    .withDirectory("/workspace/source", source)
    .withWorkdir("/workspace/source")
    .withNewFile("/tmp/run-update-readme.sh", runScript)
    .withExec(["bash", "/tmp/run-update-readme.sh"]);

  return await container.stdout();
}
